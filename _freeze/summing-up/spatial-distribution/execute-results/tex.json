{
  "hash": "5603e2ef9c356cfb129747d926553a77",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Spatial distribution - lecture\"\nexecute:\n  # echo: false\n  freeze: auto  # re-render only when source changes\nformat:\n  html:\n    code-fold: true\n    code-summary: \"Show the code\"\n---\n\n## The problem\n\nLet's say we want to calculate the average rainfall on a watershed, and we have data available for 7 stations, as shown in the figure below [Dingman, figure 4.26]:\n![](/archive/figures/dingman-figure4.26.png)\n\nThere are a number of methods for calculating the average precipitation.\n\n## Thiessen method [Voronoi diagram]\n\n@brutsaert2005hydrology, Figure 3.11\n![](/archive/figures/brutsaert-figure3.11.png)\n\nHow to compute the areas:\n![](/archive/figures/ward-figure2.15.png)\n\n\nAverage areal precipitation is a weighted sum:\n\n$$\n\\langle P \\rangle = \\frac{\\sum_i A_i P_i}{\\sum_i A_i}\n$$\n\n\nA nice way to understand the Thiessen method is depicted in the gif below (from [Wikipedia](https://commons.wikimedia.org/wiki/File:Voronoi_growth_euclidean.gif)):\n\n::: {.content-visible when-format=\"html\"}\n\n:::\n\n\n\n```{=html}\n![](Voronoi_growth_euclidean.gif)\n\n:::\n\n:::\n\n\n## Inverse distance method\n\n@brutsaert2005hydrology, Figure 3.12\n![](/archive/figures/brutsaert-figure3.12.png)\n\nThe precipitation for square 17 is\n\n$$\nP_{17} = \n\\displaystyle\\frac\n{\\displaystyle\\sum_\\text{$i$ = all stations}\\frac{P_i}{d_{i,17}^2}}\n{\\displaystyle\\sum_\\text{$i$ = all stations}\\frac{1}{d_{i,17}^2}}\n$$\n\nThe average precipitation for the whole watershed is the weighted average of all squares, where the weight is their area:\n\n$$\n\\langle P \\rangle = \n\\displaystyle\\frac\n{\\displaystyle\\sum_\\text{$j$ = all squares} A_j P_j}\n{\\displaystyle\\sum_\\text{$j$ = all squares} A_j}\n$$\n\n@brutsaert2005hydrology, page 93:  \n\n> Dean and Snyder (1977) found that the exponent (for the distance $d^{-b}$) b = 2 yielded the best results in the Piedmont region of the southeastern United States, whereas Simanton and Osborn (1980) concluded from measurements in Arizona that b can range between 1 and 3 without significantly affecting the results.\n\n## Isohyetal method\n\n@brutsaert2005hydrology, Figure 3.12\n![](/archive/figures/brutsaert-figure3.13.png)\n\nThe same equation of the Thiessen method can be used:\n\n$$\n\\langle P \\rangle = \\frac{\\sum_i A_i P_i}{\\sum_i A_i}\n$$\n\n## How it is actually done\n\nMost often, Geographic Information System (GIS) software is used to analyze spatial data. Two of the most used programs are ArcGIS (proprietary) and QGIS (free).\n\nA good discussion of the different methods can be found on [Manuel Gimond's website](https://mgimond.github.io/Spatial/spatial-interpolation.html), *Intro to GIS and Spatial Analysis*.\n\n<div class=\"alert alert-danger\">\n**Attention**!  \nDon't mix precision with accuracy. There are many ways of interpolating, just because a result seems detailed, it does not imply that it is accurate! See below three interpolation methods.</div>\n\n\n![](vohvE.jpg)\n\nBelow you can find a simple Python code that exemplifies some of the methods, producing the following figure:\n\n![](/archive/figures/spatial-distribution.png)\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.interpolate import griddata\nfrom scipy.spatial import Voronoi, voronoi_plot_2d, ConvexHull\n\nfig, ax = plt.subplots(1, 3, figsize=(10,7))\nfig.subplots_adjust(left=0.0, right=1.0, top=0.96, bottom=0.05,\n                    hspace=0.02, wspace=0.02)\n\nN = 6\nPI = '3141592653589793'\npoints = np.random.rand(N, 2)\npoints = np.vstack([points,[0,0], [0,1], [1,0], [1,1]])\nvalues = np.array([int(x) for x in list(PI)])[:(N+4)]\n# values = np.array([3, 1, 4, 1, 5, 9, 2, 6, 5, 3])\n\ngrid_x, grid_y = np.mgrid[0:1:100j, 0:1:200j]\n\ngrid_z_nearest = griddata(points, values, (grid_x, grid_y), method='nearest')\ngrid_z_cubic = griddata(points, values, (grid_x, grid_y), method='cubic')\n\nax[0].plot(points[:,0], points[:,1], 'o', ms=3, markerfacecolor=\"red\", markeredgecolor=\"red\")\nax[0].set_aspect('equal', 'box')\nax[0].set(xlim=[0,1], ylim=[0,1])\nax[0].set_title(\"the stations\")\nfor i, v in enumerate(values):\n    ax[0].text(points[i,0], points[i,1], str(v))\n\nax[1].imshow(grid_z_nearest.T, extent=(0,1,0,1), origin='lower')\nax[1].plot(points[:,0], points[:,1], 'o', ms=3, markerfacecolor=\"red\", markeredgecolor=\"red\")\nvor = Voronoi(points)\nvoronoi_plot_2d(vor, show_vertices=False, line_colors='cyan',\n                line_width=3, line_alpha=1, point_size=0, ax=ax[1])\nax[1].set_title(\"Thiessen Method\")\n\nax[2].plot(points[:,0], points[:,1], 'o', ms=3, markerfacecolor=\"red\", markeredgecolor=\"red\")\nnlines = int((values.max()-values.min()+1)/2)\nax[2].contourf(grid_x, grid_y, grid_z_cubic, nlines)\ncont = ax[2].contour(grid_x, grid_y, grid_z_cubic, nlines, colors=\"black\")\nax[2].clabel(cont, inline=1, colors='white', fmt='%.0f')\nax[2].set_title(\"Isohyetal Method\")\n\nfor i, a in enumerate(ax):\n    a.set(xlim=[-0.2,1.2], ylim=[-0.2,1.2])\n    a.axis('off')\n    a.set_aspect('equal', 'box')\n\nfig.savefig(\"spatial-distribution.png\", dpi=500)\n```\n\n::: {.cell-output .cell-output-display}\n![](spatial-distribution_files/figure-pdf/cell-2-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n",
    "supporting": [
      "spatial-distribution_files/figure-pdf"
    ],
    "filters": []
  }
}